\chapter{Исследовательский раздел}
\section{Технические характеристики}
Технические характеристии устройства, на котором выполнялось тестирование:
\begin{itemize}
	\item операционная система: Windows 10 Pro;
	\item память: 8 GiB;
	\item процессор: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz.
\end{itemize}
Тестирование проводилось на ноутбуке, который был подключен к сети питания. Во время проведения тестирования ноутбук был нагружен только встроенными приложениями окружения, самим окружением и системой тестирования.

\section{Временные харастеристики выполнения}
Ниже был проведен анализ времени работы алгоритмов. Исходными данными будут случайно сгенерированные строки длиной \{3, 4, 5, 6, 7, 8\}. Единичные замеры выдадут крайне маленький результат, поэтому  проведем работу каждого алгоритма n = 1000 раз и поделим на число n. Получим среднее значение работы каждого из алгоритмов. Результат приведен на рис \ref{fg:6_1}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Длина строки,
			ylabel = {Время, c},
			xmin = -1,% xmin=0
			width = 0.95\textwidth,
			height=0.5\textheight,
			xtick distance = 1,
			legend style={at={(0.5,-0.2)},anchor=north}]
			\addplot table{data/iterative_lev.txt};
			\addplot table{data/recursive_lev.txt};
			\addplot table{data/recursive_lev_damerau.txt};
			\addplot table{data/recursive_lev_matrix.txt};
			\legend{
				Итеративный алгоритм Левенштейна,
				Рекурсивный алгоритм Левенштейна без кэша,
				Рекурсивный алгоритм Левенштейна с матрицей,
				Рекурсивный алгоритм Дамерау-Левенштейна
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени работы алгоритмов } 
	\label{fg:6_1}
\end{figure} 

Как видно из результатов, рекурсивный алгоритм Левенштейна без кэша и алгоритм Дамерау-Левенштейна уступают по скорости выполнения, начиная уже со строки длиной 7. Рекурсивный алгоритм Левенштейна выполняется быстрее реализации с матрицей для длины строк 7, 8 на 313\%, 1369\% соответственно. Рекурсивный алгоритм Дамерау-Левенштейна выполняется быстрее реализации без кэша для длины строк 7, 8 на 337\%, 1580\% соответственно. Последний алгоритм задействует дополнительную операцию - транспозицию, которая тоже приводит к вызову рекурсии.

Выполнив анализ двух остальных алгоритмов на значения входных строк длиной \{25, 50, 75, 100, 125, 150\}, получим следующий результат, представленный на рис  \ref{fg:6_2}:
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Длина строки,
			ylabel = {Время, c},
			xmin = -1,
			width = 0.95\textwidth,
			height=0.5\textheight,
			xtick distance = 25,
			legend style={at={(0.5,-0.2)},anchor=north}]
			\addplot table{data/iterative_lev_comp.txt};
			\addplot table{data/recursive_lev_matrix_comp.txt};
			\legend{
				Итеративный алгоритм Левенштейна,
				Рекурсивный алгоритм Левенштейна с матрицей
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени работы алгоритмов нахождения расстояния} 
	\label{fg:6_2}
\end{figure} 

Рекурсивный алгоритм Левенштейна с использованием матрицы выигрывает по скорости у итеративного метода на длинах строк 50, 100, 150 примерно на 27\%, 31\%, 33\% соответсвенно. Это объясняется тем, что в итеративном случае выполняется дополнительная операция по обмену значений двух строк. На это требуется дополнительное время.

\section{Объем потребляемой памяти}
При исходных строках, длиною 3, требуется 52,8 Mb памяти. Результаты вызовов и объем потребляемой памяти приведены в таблице \ref{table:ref2}:
\begin{table}[ht!]
	\centering
	\captionsetup{singlelinecheck = false, justification=raggedleft}
	\caption{Число вызовов каждого алгоритма}
	\label{table:ref2}
	\begin{tabular}{|c|c|c|c|}
		\hline
		\multicolumn{3}{|c|}{Левенштейн} & Дамерау-Левенштейн \\ \cline{1-3} 
		\hline
		\multirow{2}{*}{Итеративный} &\multirow{2}{*}{Рекурсивный} & \multirow{2}{*}{Рекурсивный} & \multirow{2}{*}{Рекурсивный} \\
		с двумя строками & без кэша  & с матрицей & \\
		\hline
		1 & 94 & 28 & 94 \\ 
		\hline
	\end{tabular}
\end{table}\\
\\
Общее значение потребляемой памяти складывается по формуле (\ref{eq:4}).
\begin{equation}
	S = n_{calls} * V
	\label{eq:4}
\end{equation}

где:
\begin{itemize}
	\item $n_{calls}$ - число вызовов функций;
	\item V - объем памяти, занимаемый одним вызовом функции.
\end{itemize}
По результатам исследования памяти алгоритмы Левенштейна и Дамерау-Левенштейна потребляют больше памяти при выполнении по сравнению с другими (отличается от итеративного способа в 94 раз, от рекурсивного с матрицей - приблизительно 3,35 раз).

\section{Вывод}
Рекурсивный вызов Левенштейна без кэша и Дамерау-Лвенштейна проигрывают как по скорости, так и по памяти итеративному. Причем рекурсивный алгоритм Левенштейна с матрицей выигрывает по скорости выполнения итеративному с двумя строками, но при этом проигрывает ему по памяти.

Сравнивая между собой рекурсивные вызовы алгоритмов Левенштейна и Дамерау-Левенштейна, можно сделать вывод о том, что рекурретный алгоритм поиска расстояния Левенштейна с матрицей выигрывает как по времени, так и по памяти у других реализаций этих алгоритмов, а рекуррентный Дамерау-Левенштейн проигрывает им по обоим параметрам. Однако, стоит отметить, что в системах автоматического исправления текста, где чаще всего встречаются ошибки, связанные с транспозицией двух символов, выполнение исправления ошибок выбор алгоритма Дамерау-Левенштейна будет оптимальным решением.\\