\chapter{Технологический раздел}
\section{Требования к программному обеспечению}
Программа должна отвечать следующим требованиям:
\begin{itemize}
	\item на вход программе подаются два массива целых сгенерированных чисел, размер которых задает пользователь;
	\item осуществляется выбор алгоритма умножения матриц из меню;
	\item на вход программе подаются только корректные данные данные;
	\item на выходе программа выдает результат - полученную матрицу.
\end{itemize}

\section{Выбор средств реализации}
Для реализации алгоритмов в данной лабораторной работе был выбран язык программирования Python 3.9.7\cite{python3}. На нем можно выполнять быструю разработку программ. Имеется опыт разработки на этом языке. В качестве среды разработки был использован Visual Studio Code\cite{vs}, так как в нем присутсвует поддержка практически всех языков программирования. При замере процессорного времени был использован модуль time\cite{time}.

\section{Листинги программ}
Ниже представлены листинги разработанных алгоритмов умножения матриц.

\begin{lstlisting}[caption=Программный код умножения матриц стандартным способом]
def multiply_matrixes_ordinary(matrix_a, matrix_b) -> list[list[int]]:
	n, m = matrix_a.get_size()
	q, p = matrix_b.get_size()
	if m != q:
		print('Dismatch matrix sizes.')
		return
	else:
		matrix_result = Matrix(n, p)
	for i in range(n):
		for j in range(p):
			for k in range(m):
				matrix_result[i][j] = matrix_result[i][j] + \
									matrix_a[i][k] * matrix_b[k][j]
	return matrix_result
\end{lstlisting}

\begin{lstlisting}[label=some-code,caption=Программный код умножения матриц по Винограду]
def multiply_matrixes_vinograd(matrix_a, matrix_b) -> list[list[int]]:
	n, m = matrix_a.get_size()
	q, p = matrix_b.get_size()
	if m != q:
		print('Dismatch matrix sizes.')
		return
	else:
		matrix_result = Matrix(n, p)
		d = int(m / 2)
		mul_u = [0] * n
		for i in range(n):
			for j in range(d):
				mul_u[i] = mul_u[i] + \
							matrix_a[i][2*j] * matrix_a[i][2*j + 1]
		
		mul_w = [0] * p
		for i in range(p):
			for j in range(d):
				mul_w[i] = mul_w[i] + \
							matrix_b[2*j][i] * matrix_b[2*j + 1][i]
		
		for i in range(n):
			for j in range(p):
				matrix_result[i][j] = -mul_u[i] - mul_w[j]
				for k in range(d):
					matrix_result[i][j] = matrix_result[i][j] + \
					(matrix_a[i][2*k] + matrix_b[2*k+1][j]) * \
					(matrix_a[i][2*k+1] + matrix_b[2*k][j])
		
		if m % 2 == 1:
			for i in range(n):
				for j in range(p):
					matrix_result[i][j] = matrix_result[i][j] + \
								matrix_a[i][m-1] * matrix_b[m-1][j]
		
		return matrix_result
\end{lstlisting}

\begin{lstlisting}[label=some-code,caption=Программный код оптимизированного алгоритма умножения матриц по Винограду]
def multiply_matrixes_vinograd_optimized(matrix_a, matrix_b) -> list[list[int]]:
	n, m = matrix_a.get_size()
	q, p = matrix_b.get_size()
	if m != q:
		print('Несовпадение размеров матриц')
		return
	else:
		matrix_result = Matrix(n, p)
		is_odd = m % 2
		dec_m = m - 1
		mul_u = [0] * n
		if is_odd:
			m -= 1
		for i in range(n):
			buf = 0
			for j in range(0, m, 2):
				buf += matrix_a[i][j] * matrix_a[i][j + 1]
			mul_u[i] = buf
		
		mul_w = [0] * p
		for i in range(p):
			buf = 0
			for j in range(0, m, 2):
				buf += matrix_b[j][i] * matrix_b[j + 1][i]
			mul_w[i] = buf
		
		for i in range(n):
			for j in range(p):
				buf = -(mul_u[i] + mul_w[j])
				for k in range(0, m, 2):
					buf += (matrix_a[i][k] + matrix_b[k+1][j]) * \
							(matrix_a[i][k+1] + matrix_b[k][j])
		
				if is_odd == 1:
					buf += matrix_a[i][dec_m] * matrix_b[dec_m][j]
				matrix_result[i][j] = buf
		
		return matrix_result
\end{lstlisting}

\section{Вспомогательные функции}
На листингах представлены программные модули, которые используются в данных функциях:
\begin{lstlisting}[label=some-code,caption=Программный код создания для кэша в виде строки]
def create_row(len_row: int, flag_row: int) -> list[int]:
	row = list()
	if flag_row == 1:
		for i in range(len_row):
			row.append(i)
	else:
		for i in range(len_row):
			row.append(0)
	return row
\end{lstlisting}

\begin{lstlisting}[label=some-code,caption=Программный код обмена двух строк]
def swap_rows(row_1: list[int], row_2: list[int]) \
				-> Tuple[list[int], list[int]]:
	temp_row = list()
	temp_row = deepcopy(row_1)
	row_1 = deepcopy(row_2)
	row_2 = deepcopy(temp_row)
	return row_1, row_2
\end{lstlisting}

\section{Тестирование}
Для тестирования используется метод черного ящика. В данном разделе приведена таблица \ref{table:ref1}, в которой указаны классы эквивалентностей тестов: \\

\begin{table}[ht!]
	\centering
	\captionsetup{singlelinecheck = false, justification=raggedleft}
	\caption{Таблица тестов}
	\label{table:ref1}
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		\multirow{3}{*}{№} & \multirow{3}{*}{Описание теста} & \multirow{3}{*}{Слово 1}  &  \multirow{3}{*}{Слово 2}   & \multicolumn{2}{|c|}{Алгоритм}\\ \cline{5-6}
		&                &          &            &\multirow{2}{*}{Левенштейн}   &Дамерау-	\\ 
		&                &          &            &             &Левенштейн       	        \\ \hline
		1& Пустые строки  &  ''      &    ''      &   0         &  0 						\\ \hline
		\multirow{2}{*}{2}& \multirow{2}{*}{Нет повторяющихся} & \multirow{2}{*}{deepcopy} & \multirow{2}{*}{раздел} & \multirow{2}{*}{8}   &  \multirow{2}{*}{8}                      
		\\
		 & символов        &          &            &             &
		 \\ \hline
		3& Инверсия строк & insert   &tresni      &   6         &  6                       \\ \hline
		4& Два соседних символа       & heart    & heatr  & 2   &  1                       \\ \hline
		5& Одинаковые строки          & таблица  & таблица& 0   &  0						\\ \hline
		\multirow{2}{*}{6}& \multirow{2}{*}{Одна строка} &\multirow{2}{*}{город} &\multirow{2}{*}{горо} & \multirow{2}{*}{1} & \multirow{2}{*}{1} \\  
		& меньше другой   &           &           &      &\\ \hline
	\end{tabular}
\end{table}

\section*{Вывод}
В данном разделе был выбран язык программирования, среда разработки. Реализованы функции, описанные в аналитическом разделе, и проведено их тестирование методом черного ящика по таблице \ref{table:ref1}. 

